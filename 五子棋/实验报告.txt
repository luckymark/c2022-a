电子科技大学计算机学院实验中心
计算机专业类课程
实验报告
课程名称：程序设计基础 
学 院：计算机科学与工程学院 
学生姓名:苟昀峰
学 号：2020080905017
指导教师：俸志刚 
 
日 期： 2023 年 2 月 10 日 
 
电 子 科 技 大 学
实 验 报 告
一、实验名称：
人工智能五子棋
二、实验学时：约70小时
三、实验内容和目的：
使用 c语言编写一个棋力较高的五子棋 AI。
四、实验原理：
主要用到的算法有：以极大极小值搜索为基础的α-
β剪枝算法，自己编写的局面评估函数。
五、实验器材：
电脑
六、实验步骤：
1.首先通过图形库函数编写了一个简易的五子棋小程序。（6小时）
2.通过阅读资料，首先自创了一个局面评估函数，和决定落子的函数。并直接遍历进行了测试。（7+2小时）
3.然后创建了极大极小搜索函数，此阶段并未融入ab剪枝，设置搜索深度为3进行了测试。（15小时）
4.尝试进行剪枝，至此程序大体完成。（30小时）
5.尝试对代码进行模块化处理和重构。（10小时）




七、实验结果分析：


1.我的五子棋工作流程如下：
首先由玩家下棋，然后转到ai，
ai行棋时，通过findblank函数找到要进行模拟的点。
然后送入findbest函数进行深度搜索，会随机挑选一个点下棋，
然后模拟玩家的落子，
重复以上过程并在最深处进行估值，通过比较后得到最佳位置，
在这里我定义了一个p结构，包含x，y两个变量，设置一个全局变量best记录下这个最佳位置，
传入draw函数在棋盘上落子。
然后会通过judge函数进行判断是否有五个子连在一起，
如果有就将游戏结束，没有就将回合转到另一玩家。
重复以上过程直至游戏结束。

2.一些遇到的困难。
（1）不知道为什么vs调试总是暴死，导致工作效率奇低，所有遇到的困难基本只能在脑内思考或者在纸上写来解决。
（2）没有现成的ab剪枝代码做参考

3.一些函数的解释
（1）首先是估值函数evaluate，这个函数的核心在于找到连着的子有几个，如果采用if层层嵌套那么会使这个函数重复臃肿，因此我采用了另一方法
代码如下
switch (direction) {
	case 1:xc = 1; yc = 0; break;//向右
	case 2:xc = 0; yc = 1; break;//向下
	case 3:xc = 1; yc = 1; break;//右下
	case 4:xc = 1; yc = -1; break;//右上
	}
首先会这段代码会决定搜索的方向而direction由其他函数的一段for循环产生，保证四个方向都被搜素到
if (qp[y][x] != 0)
	{
		int ay = y, ax = x;
		while (ay < len && ax < len && qp[ay][ax] == qp[y][x]&&count<6) {
			ay += yc;
			ax += xc;
			count++;
		}
		if (count == 5)//连五
		{
			count += 3;
			
		}
		if (count == 4)
		{
			count += 1;
		}
		if (qp[ay][ax] != 0) {
			count--;
		}
		if (y - yc < len && x - xc < len && y < len && x < len) {
			if (qp[y - yc][x - xc] == -qp[y][x]) {
				count--;
			}
		}
然后会通过这段代码得到count（那些加加减减是为了减少被别人堵着的连子的评分，但连5和连4由于距胜利很近所以要额外在加一点）
//ps：count函数也起到判断游戏是否结束的作用


然后将count返回到真正的计分函数getscore
其核心为
int number = count(i, j, direction);
				switch (number) {
				case 2:sum += qp[j][i] * count2; break;//活二，赌三，死四
				case 3:sum += qp[j][i] * count3; break;//活三
				case 4:sum += qp[j][i] * count4; break;//只有赌四才是这个评分
				case 5:sum += qp[j][i] * count4; break;
				case 6: sum += qp[j][i] * count5;  break;//以下三个全为连5的
				case 7: sum += qp[j][i] * count5;  break;
				case 8: sum += qp[j][i] * count5;	 break;
				default:break;

其中count2，3，4，5都差了一个数量级以鼓励ai多去下更长串的

这样，就把之前的层层嵌套的估值函数从300行精简到80行，并实现了数子（count）的模块化。


（2）findblank函数
这个函数最开始我是每模拟下一颗子就会重新找一次，后来发现这样太慢了就舍弃了这种做法，
然后根据经验，发现每次下的棋其实和已有的棋相聚不远，所以只在开始模拟之前找一次，然后速度加快了一点（吧？）
同时棋力未受明显影响。

（3）minmaxab函数
没怎么搞懂的函数，因此改进比较少，因为实在不能把minmax和剪枝分开和模块化，
导致这部分代码又臭又长（一个函数一百行），也是花费时间最多的一个函数，也没什么创新处。

大致讲一下吧，int findbest(int acolor, int depth, ab last)
其中，acolor表示了正在模拟的是黑还是白，last是用于剪枝的alphabeta的一个结构，里面存了a，b两个变量，a是一个很小的数，b是一个很大的数，（初值）
在没到最深处时，每下一个子都会往下递归
value = findbest(-acolor, depth + 1, now)
到了最深处就开始evalate估值并一层一层向上传值
switch (acolor) {
	case -1:return min; break;
	case 1:return max; break;
	}
（这个来来回回改了好多次，最开始以为-1时是向上返回最大值，结果试了好久才发现是返回min。）
在depth==2时会对best这个参数进行修改，（毕竟其他层时只是模拟）达到下棋的目的


下面说说剪枝

设置了一个参数firsttime来判断ab是不是第一次修改，
if (firsttime == 1) {
		switch (acolor) {
		case -1:if (now.a < min)
		{
			now.a = min;

		}; break;
		case 1:
			if (now.b > max)
			{
				now.b = max;

			}; break;
		}



		bridge = now;

		firsttime = 0;
	}

}
只有第一次是直接根据min or max对ab赋值，其他次都是一个一个比来快速剪枝，
每次对now的修改结束后，就会对全局变量bridge赋值，起到在不同层数中起到传递的作用
对now的修改后，还会进行判断是否剪枝。

每次模拟下子后都要进行判断是否有五连的，如果有就说明到头了，需要把立刻进行估值并进行返回

（5）实现精确落到线的交汇处，
具体来说，我量了一下找到的棋盘图片的像素大小，然后设置了一个bc常量，标志每个小正方形的长度
col = getmessage(EX_MOUSE | EX_KEY);
	if (col.lbutton == 1) {
		int x = col.x / bc;
		int y = col.y / bc;
		draw_piece(x, y);
		complete = 1;


	}


然后转到这段函数
if (qp[y][x] == 0) {
		qp[y][x] = color;
		xyvalue[y][x].flag = -1;


		y = y * bc + 28;//28是距离边界的长度
		x = x * bc + 28;
		fillcircle(x, y, r);
就可以实现精确落子而不会落到奇奇怪怪的地方。



4.源文件
main.c不说
evaluate。c包含了一系列与估值有关的函数
minmaxab.c包含极大极小搜索和ab剪枝
findblank.c包含找空位的函数
menu.c包含了与五子棋游戏本身有关的函数


5.一些改进想法：
（1）估值函数的重新编写：
其实我最开始是打算对某个形状进行打分而不是对一条线进行打分
如一个四个子组成一个正方形的棋型完全可以给到与赌四相同的分，
但是考虑到代码工作量太大运行速度慢就舍弃了。
以这种思路可以把评估函数更详细也会更精确，不过我也不会下五子棋，，，，打分也不会很精确

另一种就是养蛊，在已有的count2，3，4，5的基础上再进行一些随机增减，然后让改正的ai和原始化的互相下，多养一段时间，不过我电脑应该跑不动

（2）哈希表的使用
如果使用哈希表，可以把不同过程但同一结果的模拟一起打分，大大减少叶节点的个数，不过c语言好像没有哈希表，我自己也不会编

（3）记录一些必胜定式
其实和估值函数很像，不过这样的计算量就很大很大了，我想的是或许可以把那种识别形状的函数加进来然后只要某一部分达到必胜的条件就照着定式下，
也可以让ai自己下，来寻找这些必胜定式，然后找到相似的几个来合并同类项以精简。


6.反思加后记
本来过年之前就把极大极小写完了，以为剪枝就一会的事，结果居然占到了整个程序的一半时间，导致后续的重构就没啥时间了，
vs调试也是大问题，最开始以为是指针乱指就把指针删了七七八八，还是出问题，在考虑要不要换个编译器。
不过还是学到了很多，之前写代码就是全部塞到一个main函数里面，然后迷宫学会了还是多写函数，写到五子棋发现只写函数在改的时候还是不方便就学会了分到不同源文件里
时间仓促，写的五子棋还是很简陋，谢谢老师这个学期的教导。












